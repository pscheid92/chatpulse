# ADR-013: sqlc for Type-Safe SQL

**Status:** Accepted
**Date:** 2026-02-12
**Authors:** Infrastructure Team
**Tags:** database, tooling, implementation

## Context

The application needs to execute SQL queries against PostgreSQL for user data, config, and EventSub subscriptions. Go's `database/sql` provides low-level database access but requires manual type mapping and error-prone string concatenation.

### Requirements

1. **Type safety** - Compile-time errors for type mismatches
2. **SQL-first** - Write SQL, not ORM DSL
3. **Performance** - Zero runtime overhead
4. **Maintainability** - Changes to schema/queries caught at compile-time

## Decision

Use **sqlc** to generate type-safe Go code from SQL files.

### Architecture

```
internal/database/
  â”œâ”€ sqlc/
  â”‚  â”œâ”€ schemas/         # DDL (CREATE TABLE, migrations)
  â”‚  â”‚  â”œâ”€ 001_initial.sql
  â”‚  â”‚  â”œâ”€ 002_add_overlay_uuid.sql
  â”‚  â”‚  â””â”€ ...
  â”‚  â””â”€ queries/         # DML (SELECT, INSERT, UPDATE)
  â”‚     â”œâ”€ users.sql
  â”‚     â”œâ”€ configs.sql
  â”‚     â””â”€ eventsub.sql
  â”‚
  â”œâ”€ sqlcgen/            # Generated code (committed)
  â”‚  â”œâ”€ models.go
  â”‚  â”œâ”€ users.sql.go
  â”‚  â””â”€ ...
  â”‚
  â””â”€ *_repository.go     # Repositories wrap generated code
```

### Configuration

**sqlc.yaml:**
```yaml
version: "2"
sql:
  - engine: "postgresql"
    queries: "internal/database/sqlc/queries"
    schema: "internal/database/sqlc/schemas"
    gen:
      go:
        package: "sqlcgen"
        out: "internal/database/sqlcgen"
        emit_json_tags: true
        emit_pointers_for_null_types: true
```

### Example Workflow

**1. Write SQL query:**
```sql
-- name: GetUserByID :one
SELECT id, twitch_user_id, display_name, access_token, refresh_token,
       token_expiry, overlay_uuid, created_at, updated_at
FROM users
WHERE id = $1;
```

**2. Generate Go code:**
```bash
sqlc generate
```

**3. Use generated code:**
```go
// Generated by sqlc
func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
    row := q.db.QueryRowContext(ctx, getUserByID, id)
    var user User
    err := row.Scan(&user.ID, &user.TwitchUserID, ...)
    return user, err
}

// Repository wraps generated code
func (r *UserRepo) GetByID(ctx context.Context, id uuid.UUID) (*domain.User, error) {
    dbUser, err := r.queries.GetUserByID(ctx, id)
    if errors.Is(err, pgx.ErrNoRows) {
        return nil, domain.ErrUserNotFound
    }
    return toDomainUser(dbUser, r.cipher), nil
}
```

### Dual-Purpose Schema Files

Schema files serve two purposes:

1. **tern migrations** - Runtime schema management
2. **sqlc type analysis** - Compile-time type generation

```sql
-- 001_initial.sql
-- tern migration (loaded at runtime)
-- sqlc analyzes for type generation

CREATE TABLE users (
    id UUID PRIMARY KEY,
    twitch_user_id TEXT NOT NULL UNIQUE,
    -- ...
);

---- create above / drop below ----

DROP TABLE users;
```

## Alternatives Considered

### 1. ORM (GORM, ent)

Object-relational mapping with code-first schema definition.

```go
type User struct {
    gorm.Model
    TwitchUserID string `gorm:"uniqueIndex"`
}

db.Where("twitch_user_id = ?", id).First(&user)
```

**Rejected because:**
- **N+1 query problems** - Lazy loading triggers hidden queries
- **Magic SQL** - Hard to understand/debug generated queries
- **Performance overhead** - Reflection for struct mapping
- **Complex eager loading** - Preload("Foo.Bar.Baz") magic strings

### 2. Raw SQL + Hand-Written Types

Traditional `database/sql` with manual type definitions.

```go
type User struct {
    ID           uuid.UUID
    TwitchUserID string
}

row := db.QueryRow("SELECT id, twitch_user_id FROM users WHERE id = $1", id)
var user User
err := row.Scan(&user.ID, &user.TwitchUserID)
```

**Rejected because:**
- **Type mismatches** - Forgot to update struct after schema change
- **Verbose** - Manual scan for each column
- **No compile-time safety** - SQL typos found at runtime
- **Maintenance burden** - Keep types in sync with schema manually

### 3. sqlx

Light wrapper around `database/sql` with struct scanning.

```go
type User struct {
    ID           uuid.UUID `db:"id"`
    TwitchUserID string    `db:"twitch_user_id"`
}

var user User
err := db.Get(&user, "SELECT * FROM users WHERE id = $1", id)
```

**Rejected because:**
- Still need hand-written types (no codegen)
- No compile-time safety (SQL typos at runtime)
- Reflection overhead (struct tag parsing)
- SELECT * antipattern (breaks on schema changes)

## Consequences

### Positive

âœ… **Type safety** - Compile-time errors for mismatched types
âœ… **SQL-first** - Write SQL, not ORM DSL (full PostgreSQL features)
âœ… **Zero runtime overhead** - Generated code, no reflection
âœ… **Excellent performance** - Direct column mapping
âœ… **Explicit queries** - All SQL visible in `.sql` files
âœ… **IDE support** - Generated code has autocomplete

### Negative

âŒ **Codegen step** - Must run `sqlc generate` after query changes
âŒ **Boilerplate** - Generated files committed (500-1000 lines)
âŒ **PostgreSQL-only** - Can't easily swap to MySQL
âŒ **Learning curve** - sqlc comment syntax (`-- name: GetUser :one`)

### Trade-offs

ðŸ”„ **Type safety over zero-codegen** - Accept codegen for compile-time guarantees
ðŸ”„ **Performance over portability** - PostgreSQL-specific > database-agnostic ORM
ðŸ”„ **Explicitness over magic** - Visible SQL > hidden ORM queries

## Integration with Migrations

**Migration tool:** tern (embedded SQL files)

**Workflow:**
1. Write migration: `internal/database/sqlc/schemas/003_add_column.sql`
2. Run migration: `tern migrate` (production) or `database.RunMigrations()` (code)
3. Update query: `internal/database/sqlc/queries/users.sql` (add new column)
4. Generate code: `sqlc generate`
5. Update repository: Use generated method

**Dual-purpose schemas:**
- tern reads files at runtime (apply migrations)
- sqlc reads files at compile-time (type analysis)

## Testing Strategy

**Unit tests use real generated code:**
```go
func TestUserRepo_GetByID(t *testing.T) {
    // Use testcontainers for real PostgreSQL
    pool := setupTestDB(t)
    repo := database.NewUserRepo(pool, crypto.NoopService{})

    user, err := repo.GetByID(ctx, testUserID)
    require.NoError(t, err)
    assert.Equal(t, "test_user", user.TwitchUserID)
}
```

**Benefits:**
- Tests exercise real SQL (catch query bugs)
- Generated code tested (not mocked)
- Production fidelity (same code path)

## Error Handling Pattern

**Repository layer translates errors:**
```go
func (r *UserRepo) GetByID(ctx, id) (*domain.User, error) {
    dbUser, err := r.queries.GetUserByID(ctx, id)
    if errors.Is(err, pgx.ErrNoRows) {
        return nil, domain.ErrUserNotFound  // Domain error
    }
    if err != nil {
        return nil, fmt.Errorf("failed to get user: %w", err)
    }
    return toDomainUser(dbUser, r.cipher), nil
}
```

**Pattern:**
- **Sentinel errors for not-found** - `domain.ErrUserNotFound`
- **Wrapped errors for failures** - `fmt.Errorf(...: %w, err)`
- **No pgx types leak** - Consumers never import `github.com/jackc/pgx`

## Related Decisions

- **ADR-012: Manual DI** - Repositories constructed in `main.go`
- **Token encryption at rest** - `cipher.AEAD` injected into repositories

## Implementation

**Files:**
- `sqlc.yaml` - Configuration
- `internal/database/sqlc/schemas/*.sql` - Migrations (dual-purpose)
- `internal/database/sqlc/queries/*.sql` - Query definitions
- `internal/database/sqlcgen/*.go` - Generated code (committed)
- `internal/database/*_repository.go` - Repositories wrap generated code

**Commit:** Initial implementation (2025-12)

## Future Considerations

**If query complexity grows:**
- Consider hand-written SQL for complex joins (sqlc still validates types)
- Use CTEs, window functions (full PostgreSQL power)

**If portability needed:**
- Keep sqlc for PostgreSQL
- Add MySQL adapter layer (translate domain â†’ MySQL queries)

## References

- [sqlc documentation](https://docs.sqlc.dev/)
- [pgx - PostgreSQL driver](https://github.com/jackc/pgx)
- [tern - Migration tool](https://github.com/jackc/tern)
