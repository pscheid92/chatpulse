// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: eventsub.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/pscheid92/uuid"
)

const createEventSubSubscription = `-- name: CreateEventSubSubscription :exec
INSERT INTO eventsub_subscriptions (
    streamer_id,
    subscription_id,
    conduit_id,
    created_at
)
VALUES ($1, $2, $3, NOW())
ON CONFLICT (streamer_id) DO UPDATE
    SET subscription_id     = EXCLUDED.subscription_id,
        conduit_id          = EXCLUDED.conduit_id
`

type CreateEventSubSubscriptionParams struct {
	StreamerID     uuid.UUID
	SubscriptionID string
	ConduitID      string
}

func (q *Queries) CreateEventSubSubscription(ctx context.Context, arg CreateEventSubSubscriptionParams) error {
	_, err := q.db.Exec(ctx, createEventSubSubscription, arg.StreamerID, arg.SubscriptionID, arg.ConduitID)
	return err
}

const deleteEventSubByConduitID = `-- name: DeleteEventSubByConduitID :exec
DELETE
FROM eventsub_subscriptions
WHERE conduit_id = $1
`

func (q *Queries) DeleteEventSubByConduitID(ctx context.Context, conduitID string) error {
	_, err := q.db.Exec(ctx, deleteEventSubByConduitID, conduitID)
	return err
}

const deleteEventSubByStreamerID = `-- name: DeleteEventSubByStreamerID :exec
DELETE
FROM eventsub_subscriptions
WHERE streamer_id = $1
`

func (q *Queries) DeleteEventSubByStreamerID(ctx context.Context, streamerID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEventSubByStreamerID, streamerID)
	return err
}

const getEventSubByStreamerID = `-- name: GetEventSubByStreamerID :one
SELECT e.streamer_id,
       s.twitch_user_id AS broadcaster_user_id,
       e.subscription_id,
       e.conduit_id,
       e.created_at
FROM eventsub_subscriptions e
JOIN streamers s ON e.streamer_id = s.id
WHERE e.streamer_id = $1
`

type GetEventSubByStreamerIDRow struct {
	StreamerID        uuid.UUID
	BroadcasterUserID string
	SubscriptionID    string
	ConduitID         string
	CreatedAt         time.Time
}

func (q *Queries) GetEventSubByStreamerID(ctx context.Context, streamerID uuid.UUID) (GetEventSubByStreamerIDRow, error) {
	row := q.db.QueryRow(ctx, getEventSubByStreamerID, streamerID)
	var i GetEventSubByStreamerIDRow
	err := row.Scan(
		&i.StreamerID,
		&i.BroadcasterUserID,
		&i.SubscriptionID,
		&i.ConduitID,
		&i.CreatedAt,
	)
	return i, err
}

const listEventSubSubscriptions = `-- name: ListEventSubSubscriptions :many
SELECT e.streamer_id,
       s.twitch_user_id AS broadcaster_user_id,
       e.subscription_id,
       e.conduit_id,
       e.created_at
FROM eventsub_subscriptions e
JOIN streamers s ON e.streamer_id = s.id
`

type ListEventSubSubscriptionsRow struct {
	StreamerID        uuid.UUID
	BroadcasterUserID string
	SubscriptionID    string
	ConduitID         string
	CreatedAt         time.Time
}

func (q *Queries) ListEventSubSubscriptions(ctx context.Context) ([]ListEventSubSubscriptionsRow, error) {
	rows, err := q.db.Query(ctx, listEventSubSubscriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventSubSubscriptionsRow{}
	for rows.Next() {
		var i ListEventSubSubscriptionsRow
		if err := rows.Scan(
			&i.StreamerID,
			&i.BroadcasterUserID,
			&i.SubscriptionID,
			&i.ConduitID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
