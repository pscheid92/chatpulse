// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const getUserByID = `-- name: GetUserByID :one
SELECT id, overlay_uuid, twitch_user_id, twitch_username,
       access_token, refresh_token, token_expiry, created_at, updated_at
FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.OverlayUUID,
		&i.TwitchUserID,
		&i.TwitchUsername,
		&i.AccessToken,
		&i.RefreshToken,
		&i.TokenExpiry,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByOverlayUUID = `-- name: GetUserByOverlayUUID :one
SELECT id, overlay_uuid, twitch_user_id, twitch_username,
       access_token, refresh_token, token_expiry, created_at, updated_at
FROM users WHERE overlay_uuid = $1
`

func (q *Queries) GetUserByOverlayUUID(ctx context.Context, overlayUuid uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByOverlayUUID, overlayUuid)
	var i User
	err := row.Scan(
		&i.ID,
		&i.OverlayUUID,
		&i.TwitchUserID,
		&i.TwitchUsername,
		&i.AccessToken,
		&i.RefreshToken,
		&i.TokenExpiry,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertDefaultConfig = `-- name: InsertDefaultConfig :exec
INSERT INTO configs (user_id, created_at, updated_at)
VALUES ($1, NOW(), NOW())
ON CONFLICT (user_id) DO NOTHING
`

func (q *Queries) InsertDefaultConfig(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, insertDefaultConfig, userID)
	return err
}

const rotateOverlayUUID = `-- name: RotateOverlayUUID :one
UPDATE users
SET overlay_uuid = gen_random_uuid(), updated_at = NOW()
WHERE id = $1
RETURNING overlay_uuid
`

func (q *Queries) RotateOverlayUUID(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, rotateOverlayUUID, id)
	var overlay_uuid uuid.UUID
	err := row.Scan(&overlay_uuid)
	return overlay_uuid, err
}

const updateTokens = `-- name: UpdateTokens :exec
UPDATE users
SET access_token = $1, refresh_token = $2, token_expiry = $3, updated_at = NOW()
WHERE id = $4
`

type UpdateTokensParams struct {
	AccessToken  string
	RefreshToken string
	TokenExpiry  time.Time
	ID           uuid.UUID
}

func (q *Queries) UpdateTokens(ctx context.Context, arg UpdateTokensParams) error {
	_, err := q.db.Exec(ctx, updateTokens,
		arg.AccessToken,
		arg.RefreshToken,
		arg.TokenExpiry,
		arg.ID,
	)
	return err
}

const upsertUser = `-- name: UpsertUser :one
INSERT INTO users (twitch_user_id, twitch_username, access_token, refresh_token, token_expiry, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, NOW(), NOW())
ON CONFLICT (twitch_user_id) DO UPDATE SET
    twitch_username = EXCLUDED.twitch_username,
    access_token = EXCLUDED.access_token,
    refresh_token = EXCLUDED.refresh_token,
    token_expiry = EXCLUDED.token_expiry,
    updated_at = NOW()
RETURNING id, overlay_uuid, twitch_user_id, twitch_username,
          access_token, refresh_token, token_expiry, created_at, updated_at
`

type UpsertUserParams struct {
	TwitchUserID   string
	TwitchUsername string
	AccessToken    string
	RefreshToken   string
	TokenExpiry    time.Time
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (User, error) {
	row := q.db.QueryRow(ctx, upsertUser,
		arg.TwitchUserID,
		arg.TwitchUsername,
		arg.AccessToken,
		arg.RefreshToken,
		arg.TokenExpiry,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.OverlayUUID,
		&i.TwitchUserID,
		&i.TwitchUsername,
		&i.AccessToken,
		&i.RefreshToken,
		&i.TokenExpiry,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
